# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from (select * from t) where v2 > 1;
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
      └─LogicalProject { exprs: [t.v1, t.v2] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
- name: merge and then eliminate
  sql: |
    create table t (v1 bigint, v2 double precision);
    select a1 as v1, a2 as v2 from (select v1 as a1, v2 as a2 from t);
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2] }
    └─LogicalProject { exprs: [t.v1, t.v2] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, columns: [t.v1, t.v2] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from (select v2, v1 as v3 from t) where v2 > 1;
  binder_error: 'Item not found: Invalid column: v1'
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v3 from (select v2, v1 as v3 from t) where v2 > 1;
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
      └─LogicalProject { exprs: [t.v2, t.v1] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
- name: consecutive projects are merged
  sql: |
    create table t (v1 bigint, v2 double precision);
    select v1, 2 from (select v1, v2, 1 from t);
  logical_plan: |
    LogicalProject { exprs: [t.v1, 2:Int32] }
    └─LogicalProject { exprs: [t.v1, t.v2, 1:Int32] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.v1, 2:Int32] }
    └─LogicalScan { table: t, columns: [t.v1] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t);
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2] }
    └─LogicalProject { exprs: [t.v1, t.v2] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, columns: [t.v1, t.v2] }
- name: joins
  sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t), t;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v1, t.v2] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalProject { exprs: [t.v1, t.v2] }
      | └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
- name: table alias
  sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) as tt join t on tt.v1=t.v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v1, t.v2] }
    └─LogicalJoin { type: Inner, on: (t.v1 = t.v1), output: all }
      ├─LogicalProject { exprs: [t.v1, t.v2] }
      | └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
- name: alias less columns than available
  sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) as tt(a) join t on a=v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v1, t.v2] }
    └─LogicalJoin { type: Inner, on: (t.v1 = t.v1), output: all }
      ├─LogicalProject { exprs: [t.v1, t.v2] }
      | └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
- name: alias more columns than available
  sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) as tt(a, b, c) join t on a=v1;
  binder_error: 'Bind error: table "tt" has 2 columns available but 3 column aliases specified'
- sql: |
    create table t(x int);
    select * from t, (select * from t as t2 order by t.x desc) as t3;
  binder_error: 'Item not found: Invalid column: x'
- sql: |
    create table t(x int);
    select * from t, (select t.x) as t1;
  binder_error: 'Item not found: Invalid column: x'
- sql: |
    create table t(x int);
    select * from t JOIN (select t.x) as t1;
  binder_error: 'Item not found: Invalid column: x'
- sql: |
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table t (v1 int, v2 varchar);
    select * from ab where exists (
      select * from bc, (
          select * from t where v1 = a
      ) as t0
    );
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(ab.a, bc.b), output: all }
    ├─LogicalScan { table: ab, columns: [ab.a, ab.b] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalScan { table: bc, columns: [bc.b] }
      └─LogicalScan { table: t, output_columns: [], required_columns: [t.v1], predicate: IsNotNull(t.v1) }
- name: We cannot reference columns in left table if not lateral
  sql: |
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table t (v1 int, v2 varchar);
    select * from ab where exists (
      select * from bc, (
          select * from t where v1 = c
      ) as t0
    );
  binder_error: 'Item not found: Invalid column: c'
- name: We need to ensure doubly nested reference to a left table is not permitted
  sql: |
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table t (v1 int, v2 int);
    select * from ab, (
      select * from bc, (
          select * from t where v1 = a
      ) as t0
    );
  binder_error: 'Item not found: Invalid column: a'
- sql: |
    create table t1 (x int, y int);
    create table t2 (x int, y int);
    select count(1) from (select sum(distinct 1) from t1), t2;
  logical_plan: |
    LogicalProject { exprs: [count(1:Int32)] }
    └─LogicalAgg { aggs: [count(1:Int32)] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalJoin { type: Inner, on: true, output: all }
          ├─LogicalProject { exprs: [sum(distinct 1:Int32)] }
          | └─LogicalAgg { aggs: [sum(distinct 1:Int32)] }
          |   └─LogicalProject { exprs: [1:Int32] }
          |     └─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.x, t2.y, t2._row_id] }
  optimized_logical_plan: |
    LogicalAgg { aggs: [count(1:Int32)] }
    └─LogicalProject { exprs: [1:Int32] }
      └─LogicalJoin { type: Inner, on: true, output: all }
        ├─LogicalAgg { aggs: [] }
        | └─LogicalScan { table: t1, columns: [] }
        └─LogicalScan { table: t2, columns: [] }
  batch_plan: |
    BatchSimpleAgg { aggs: [count(1:Int32)] }
    └─BatchProject { exprs: [1:Int32] }
      └─BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
        ├─BatchSimpleAgg { aggs: [] }
        | └─BatchExchange { order: [], dist: Single }
        |   └─BatchSimpleAgg { aggs: [] }
        |     └─BatchScan { table: t1, columns: [], distribution: SomeShard }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: t2, columns: [], distribution: SomeShard }
- sql: |
    SELECT n.nspname as "Schema",
    c.relname as "Name",
    CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 't' THEN 'TOAST table' WHEN 'f' THEN 'foreign table' WHEN 'p' THEN 'partitioned table' WHEN 'I' THEN 'partitioned index' END as "Type",
    pg_catalog.pg_get_userbyid(c.relowner) as "Owner"
    FROM pg_catalog.pg_class c
    LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    WHERE c.relkind IN ('r','p','v','m','S','f','')
    AND n.nspname <> 'pg_catalog'
    AND n.nspname !~ '^pg_toast'
    AND n.nspname <> 'information_schema'
    AND pg_catalog.pg_table_is_visible(c.oid)
    ORDER BY 1,2;
  logical_plan: |
    LogicalProject { exprs: [pg_namespace.nspname, pg_class.relname, Case((pg_class.relkind = 'r':Varchar), 'table':Varchar, (pg_class.relkind = 'v':Varchar), 'view':Varchar, (pg_class.relkind = 'm':Varchar), 'materialized view':Varchar, (pg_class.relkind = 'i':Varchar), 'index':Varchar, (pg_class.relkind = 'S':Varchar), 'sequence':Varchar, (pg_class.relkind = 's':Varchar), 'special':Varchar, (pg_class.relkind = 't':Varchar), 'TOAST table':Varchar, (pg_class.relkind = 'f':Varchar), 'foreign table':Varchar, (pg_class.relkind = 'p':Varchar), 'partitioned table':Varchar, (pg_class.relkind = 'I':Varchar), 'partitioned index':Varchar), pg_user.name] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalFilter { predicate: In(pg_class.relkind, 'r':Varchar, 'p':Varchar, 'v':Varchar, 'm':Varchar, 'S':Varchar, 'f':Varchar, '':Varchar) AND (pg_namespace.nspname <> 'pg_catalog':Varchar) AND IsNull(RegexpMatch(pg_namespace.nspname, '^pg_toast':Varchar)) AND (pg_namespace.nspname <> 'information_schema':Varchar) }
      | └─LogicalJoin { type: LeftOuter, on: (pg_namespace.oid = pg_class.relnamespace), output: all }
      |   ├─LogicalScan { table: pg_class, columns: [pg_class.oid, pg_class.relname, pg_class.relnamespace, pg_class.relowner, pg_class.relkind, pg_class.relam, pg_class.reltablespace] }
      |   └─LogicalScan { table: pg_namespace, columns: [pg_namespace.oid, pg_namespace.nspname, pg_namespace.nspowner, pg_namespace.nspacl] }
      └─LogicalProject { exprs: [pg_user.name] }
        └─LogicalFilter { predicate: (CorrelatedInputRef { index: 3, correlated_id: 1 } = pg_user.usesysid) }
          └─LogicalScan { table: pg_user, columns: [pg_user.usesysid, pg_user.name, pg_user.usecreatedb, pg_user.usesuper, pg_user.passwd] }
  batch_plan: |
    BatchExchange { order: [pg_namespace.nspname ASC, pg_class.relname ASC], dist: Single }
    └─BatchProject { exprs: [pg_namespace.nspname, pg_class.relname, Case((pg_class.relkind = 'r':Varchar), 'table':Varchar, (pg_class.relkind = 'v':Varchar), 'view':Varchar, (pg_class.relkind = 'm':Varchar), 'materialized view':Varchar, (pg_class.relkind = 'i':Varchar), 'index':Varchar, (pg_class.relkind = 'S':Varchar), 'sequence':Varchar, (pg_class.relkind = 's':Varchar), 'special':Varchar, (pg_class.relkind = 't':Varchar), 'TOAST table':Varchar, (pg_class.relkind = 'f':Varchar), 'foreign table':Varchar, (pg_class.relkind = 'p':Varchar), 'partitioned table':Varchar, (pg_class.relkind = 'I':Varchar), 'partitioned index':Varchar), pg_user.name] }
      └─BatchSort { order: [pg_namespace.nspname ASC, pg_class.relname ASC] }
        └─BatchHashJoin { type: LeftOuter, predicate: pg_class.relowner = pg_user.usesysid, output: [pg_class.relname, pg_class.relkind, pg_namespace.nspname, pg_user.name] }
          ├─BatchExchange { order: [], dist: HashShard(pg_class.relowner) }
          | └─BatchHashJoin { type: Inner, predicate: pg_class.relnamespace = pg_namespace.oid, output: [pg_class.relname, pg_class.relowner, pg_class.relkind, pg_namespace.nspname] }
          |   ├─BatchExchange { order: [], dist: HashShard(pg_class.relnamespace) }
          |   | └─BatchFilter { predicate: In(pg_class.relkind, 'r':Varchar, 'p':Varchar, 'v':Varchar, 'm':Varchar, 'S':Varchar, 'f':Varchar, '':Varchar) }
          |   |   └─BatchScan { table: pg_class, columns: [pg_class.relname, pg_class.relnamespace, pg_class.relowner, pg_class.relkind], distribution: Single }
          |   └─BatchExchange { order: [], dist: HashShard(pg_namespace.oid) }
          |     └─BatchFilter { predicate: (pg_namespace.nspname <> 'pg_catalog':Varchar) AND IsNull(RegexpMatch(pg_namespace.nspname, '^pg_toast':Varchar)) AND (pg_namespace.nspname <> 'information_schema':Varchar) }
          |       └─BatchScan { table: pg_namespace, columns: [pg_namespace.oid, pg_namespace.nspname], distribution: Single }
          └─BatchExchange { order: [], dist: HashShard(pg_user.usesysid) }
            └─BatchProject { exprs: [pg_user.name, pg_user.usesysid] }
              └─BatchScan { table: pg_user, columns: [pg_user.usesysid, pg_user.name], distribution: Single }
- sql: |
    create table auction (date_time date);
    select * from hop( auction, auction.date_time, INTERVAL '1', INTERVAL '3600' ) AS hop_1
    where EXISTS (select hop_1.date_time group by hop_1.date_time);
  logical_plan: |
    LogicalProject { exprs: [auction.date_time, window_start, window_end] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalHopWindow { time_col: auction.date_time, slide: 00:00:01, size: 01:00:00, output: all }
      | └─LogicalScan { table: auction, columns: [auction.date_time, auction._row_id] }
      └─LogicalProject { exprs: [CorrelatedInputRef { index: 0, correlated_id: 1 }] }
        └─LogicalAgg { group_key: [CorrelatedInputRef { index: 0, correlated_id: 1 }], aggs: [] }
          └─LogicalProject { exprs: [CorrelatedInputRef { index: 0, correlated_id: 1 }] }
            └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(auction.date_time, auction.date_time), output: all }
    ├─LogicalProject { exprs: [auction.date_time, window_start, window_end] }
    | └─LogicalShare { id = 33 }
    |   └─LogicalProject { exprs: [auction.date_time, null:Int64, window_start, window_end] }
    |     └─LogicalHopWindow { time_col: auction.date_time, slide: 00:00:01, size: 01:00:00, output: all }
    |       └─LogicalScan { table: auction, columns: [auction.date_time] }
    └─LogicalProject { exprs: [auction.date_time] }
      └─LogicalAgg { group_key: [auction.date_time, auction.date_time], aggs: [] }
        └─LogicalJoin { type: Inner, on: true, output: [auction.date_time, auction.date_time] }
          ├─LogicalAgg { group_key: [auction.date_time], aggs: [] }
          | └─LogicalShare { id = 33 }
          |   └─LogicalProject { exprs: [auction.date_time, null:Int64, window_start, window_end] }
          |     └─LogicalHopWindow { time_col: auction.date_time, slide: 00:00:01, size: 01:00:00, output: all }
          |       └─LogicalScan { table: auction, columns: [auction.date_time] }
          └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftSemi, predicate: auction.date_time IS NOT DISTINCT FROM auction.date_time, output: all }
      ├─BatchExchange { order: [], dist: HashShard(auction.date_time) }
      | └─BatchProject { exprs: [auction.date_time, window_start, window_end] }
      |   └─BatchHopWindow { time_col: auction.date_time, slide: 00:00:01, size: 01:00:00, output: all }
      |     └─BatchScan { table: auction, columns: [auction.date_time], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(auction.date_time) }
        └─BatchProject { exprs: [auction.date_time] }
          └─BatchHashAgg { group_key: [auction.date_time, auction.date_time], aggs: [] }
            └─BatchExchange { order: [], dist: HashShard(auction.date_time, auction.date_time) }
              └─BatchNestedLoopJoin { type: Inner, predicate: true, output: [auction.date_time, auction.date_time] }
                ├─BatchExchange { order: [], dist: Single }
                | └─BatchHashAgg { group_key: [auction.date_time], aggs: [] }
                |   └─BatchExchange { order: [], dist: HashShard(auction.date_time) }
                |     └─BatchProject { exprs: [auction.date_time, null:Int64, window_start, window_end] }
                |       └─BatchHopWindow { time_col: auction.date_time, slide: 00:00:01, size: 01:00:00, output: all }
                |         └─BatchScan { table: auction, columns: [auction.date_time], distribution: SomeShard }
                └─BatchValues { rows: [[]] }
- sql: |
    CREATE TABLE t (v int);
    SELECT 1 FROM t AS t_inner WHERE EXISTS ( SELECT 1 HAVING t_inner.v > 1);
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: t, columns: [t.v, t._row_id] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } > 1:Int32) }
          └─LogicalAgg { aggs: [] }
            └─LogicalProject { exprs: [] }
              └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  optimized_logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalJoin { type: LeftSemi, on: true, output: all }
      ├─LogicalScan { table: t, output_columns: [], required_columns: [t.v], predicate: (t.v > 1:Int32) }
      └─LogicalAgg { aggs: [] }
        └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    create table a (a1 int, a2 int);
    create table b (b1 int, b2 int);
    create table c (c1 int, c2 int);
    select 1 from a where exists ( select 1 from b having exists ( select a1 from c ));
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
      ├─LogicalScan { table: a, columns: [a.a1, a.a2, a._row_id] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalApply { type: LeftSemi, on: true, correlated_id: 2 }
          ├─LogicalAgg { aggs: [] }
          | └─LogicalProject { exprs: [] }
          |   └─LogicalScan { table: b, columns: [b.b1, b.b2, b._row_id] }
          └─LogicalProject { exprs: [CorrelatedInputRef { index: 0, correlated_id: 1 }] }
            └─LogicalScan { table: c, columns: [c.c1, c.c2, c._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(a.a1, a.a1), output: [] }
      ├─LogicalScan { table: a, columns: [a.a1] }
      └─LogicalJoin { type: LeftSemi, on: IsNotDistinctFrom(a.a1, a.a1), output: all }
        ├─LogicalAgg { group_key: [a.a1], aggs: [] }
        | └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.a1, a.a1), output: [a.a1] }
        |   ├─LogicalAgg { group_key: [a.a1], aggs: [] }
        |   | └─LogicalScan { table: a, columns: [a.a1] }
        |   └─LogicalJoin { type: Inner, on: true, output: all }
        |     ├─LogicalAgg { group_key: [a.a1], aggs: [] }
        |     | └─LogicalScan { table: a, columns: [a.a1] }
        |     └─LogicalScan { table: b, columns: [] }
        └─LogicalJoin { type: Inner, on: true, output: all }
          ├─LogicalAgg { group_key: [a.a1], aggs: [] }
          | └─LogicalScan { table: a, columns: [a.a1] }
          └─LogicalScan { table: c, columns: [] }
- sql: |
    create table a(a1 int, a2 int);
    create table b(b1 int, b2 int);
    select * from a where a1 = (select min(b1) from b where b2 = (select min(b1) from (select b1 from b where b1 = a1) as z ) );
  logical_plan: |
    LogicalProject { exprs: [a.a1, a.a2] }
    └─LogicalFilter { predicate: (a.a1 = min(b.b1)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalScan { table: a, columns: [a.a1, a.a2, a._row_id] }
        └─LogicalProject { exprs: [min(b.b1)] }
          └─LogicalAgg { aggs: [min(b.b1)] }
            └─LogicalProject { exprs: [b.b1] }
              └─LogicalFilter { predicate: (b.b2 = min(b.b1)) }
                └─LogicalApply { type: LeftOuter, on: true, correlated_id: 2, max_one_row: true }
                  ├─LogicalScan { table: b, columns: [b.b1, b.b2, b._row_id] }
                  └─LogicalProject { exprs: [min(b.b1)] }
                    └─LogicalAgg { aggs: [min(b.b1)] }
                      └─LogicalProject { exprs: [b.b1] }
                        └─LogicalProject { exprs: [b.b1] }
                          └─LogicalFilter { predicate: (b.b1 = CorrelatedInputRef { index: 0, correlated_id: 1 }) }
                            └─LogicalScan { table: b, columns: [b.b1, b.b2, b._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: IsNotDistinctFrom(a.a1, a.a1) AND (a.a1 = min(b.b2)), output: [a.a1, a.a2] }
    ├─LogicalScan { table: a, columns: [a.a1, a.a2] }
    └─LogicalAgg { group_key: [a.a1], aggs: [min(b.b2)] }
      └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.a1, b.b1), output: [a.a1, b.b2] }
        ├─LogicalAgg { group_key: [a.a1], aggs: [] }
        | └─LogicalScan { table: a, columns: [a.a1] }
        └─LogicalJoin { type: Inner, on: (b.b2 = min(b.b1)), output: [b.b1, b.b2] }
          ├─LogicalScan { table: b, columns: [b.b1, b.b2] }
          └─LogicalProject { exprs: [min(b.b1)] }
            └─LogicalAgg { group_key: [a.a1], aggs: [min(b.b1)] }
              └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(a.a1, b.b1), output: [a.a1, b.b1] }
                ├─LogicalAgg { group_key: [a.a1], aggs: [] }
                | └─LogicalScan { table: a, columns: [a.a1] }
                └─LogicalProject { exprs: [b.b1, b.b1] }
                  └─LogicalScan { table: b, columns: [b.b1], predicate: IsNotNull(b.b1) }
- name: test subquery in join on condition
  sql: |
    create table a (v1 int, v2 int);
    create table b (v1 int, v2 int);
    create table c (v1 int, v2 int);
    select * from a left outer join b on a.v1 = b.v1 and a.v2 = (select v2 from c where v1 = 1 limit 1);
  planner_error: |-
    Feature is not yet implemented: Subquery in join on condition is unsupported
    No tracking issue yet. Feel free to submit a feature request at https://github.com/risingwavelabs/risingwave/issues/new?labels=type%2Ffeature&template=feature_request.yml

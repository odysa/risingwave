# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Always false should not be pushed below SimpleAgg
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    select min(v1) from t having false;
  logical_plan: |
    LogicalProject { exprs: [min(t.v1)] }
    └─LogicalFilter { predicate: false:Boolean }
      └─LogicalAgg { aggs: [min(t.v1)] }
        └─LogicalProject { exprs: [t.v1] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: false:Boolean }
    └─LogicalAgg { aggs: [min(t.v1)] }
      └─LogicalScan { table: t, columns: [t.v1] }
- name: filter should not transpose limit
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    with cte as (select * from t limit 10) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalLimit { limit: 10, offset: 0 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
    └─LogicalLimit { limit: 10, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4] }
- name: filter should not transpose TopN
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int);
    with cte as (select * from t order by v1 limit 10 ) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
      └─LogicalTopN { order: "[t.v1 ASC]", limit: 10, offset: 0 }
        └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) }
    └─LogicalTopN { order: "[t.v1 ASC]", limit: 10, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4] }
- name: filter hop transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select * from hop(t, ts, interval '1' day, interval '3' day))
    select * from cte
    where v1=10 AND v2=20 AND v3=30 AND ts >= date '1997-07-01'
    AND window_start >= date '1997-07-02' AND window_end >= date '1997-07-03'
    AND window_start >= ts + interval '1' day AND window_end > ts + interval '4' day;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, t.ts, window_start, window_end] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.ts >= '1997-07-01':Varchar::Date) AND (window_start >= '1997-07-02':Varchar::Date) AND (window_end >= '1997-07-03':Varchar::Date) AND (window_start >= (t.ts + '1 day':Interval)) AND (window_end > (t.ts + '4 days':Interval)) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, t.ts, window_start, window_end] }
        └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (window_start >= '1997-07-02':Varchar::Date) AND (window_end >= '1997-07-03':Varchar::Date) AND (window_start >= (t.ts + '1 day':Interval)) AND (window_end > (t.ts + '4 days':Interval)) }
    └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts], predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.ts >= '1997-07-01':Varchar::Date) }
- name: filter hop transpose with non-trivial output-indices
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select window_end, v4, v2 from hop(t, ts, interval '1' day, interval '3' day))
    select * from cte where window_end > date '2022-01-01' AND v4=10 AND v2 > 20
  logical_plan: |
    LogicalProject { exprs: [window_end, t.v4, t.v2] }
    └─LogicalFilter { predicate: (window_end > '2022-01-01':Varchar::Date) AND (t.v4 = 10:Int32) AND (t.v2 > 20:Int32) }
      └─LogicalProject { exprs: [window_end, t.v4, t.v2] }
        └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: all }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [window_end, t.v4, t.v2] }
    └─LogicalFilter { predicate: (window_end > '2022-01-01':Varchar::Date) }
      └─LogicalHopWindow { time_col: t.ts, slide: 1 day, size: 3 days, output: [t.v2, t.v4, window_end] }
        └─LogicalScan { table: t, columns: [t.v2, t.v4, t.ts], predicate: (t.v4 = 10:Int32) AND (t.v2 > 20:Int32) }
- name: filter union transpose
  sql: |
    create table t1 (v1 int, v2 int, v3 int);
    create table t2 (v1 int, v2 int, v3 int);
    with cte as (select * from t1 union all select * from t2) select * from cte where v1=10 AND v2=20 AND v3=30;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t1.v3] }
    └─LogicalFilter { predicate: (t1.v1 = 10:Int32) AND (t1.v2 = 20:Int32) AND (t1.v3 = 30:Int32) }
      └─LogicalUnion { all: true }
        ├─LogicalProject { exprs: [t1.v1, t1.v2, t1.v3] }
        | └─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3, t1._row_id] }
        └─LogicalProject { exprs: [t2.v1, t2.v2, t2.v3] }
          └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3, t2._row_id] }
  optimized_logical_plan: |
    LogicalUnion { all: true }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3], predicate: (t1.v1 = 10:Int32) AND (t1.v2 = 20:Int32) AND (t1.v3 = 30:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3], predicate: (t2.v1 = 10:Int32) AND (t2.v2 = 20:Int32) AND (t2.v3 = 30:Int32) }
- name: filter project transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select v1,v2,v3,v4,v1+v2 as expr_a, v3*v4 as expr_b from t) select * from cte where expr_a>10 AND v1=10 AND v2=20 AND v3=30 AND expr_a > expr_b AND expr_a > v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2), (t.v3 * t.v4)] }
    └─LogicalFilter { predicate: ((t.v1 + t.v2) > 10:Int32) AND (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND ((t.v1 + t.v2) > (t.v3 * t.v4)) AND ((t.v1 + t.v2) > t.v1) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2), (t.v3 * t.v4)] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, t.v4, (t.v1 + t.v2), (t.v3 * t.v4)] }
    └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4], predicate: ((t.v1 + t.v2) > 10:Int32) AND (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND ((t.v1 + t.v2) > (t.v3 * t.v4)) AND ((t.v1 + t.v2) > t.v1) }
- name: filter agg transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, v4 int, ts date);
    with cte as (select v1, v2, v3, count(*) as cnt, count(1) as cnt2 from t group by v1, v2, v3) select * from cte where v1=10 AND v2=20 AND v3=30 AND cnt > v1 AND v2 > v3 AND cnt > cnt2;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, count, count(1:Int32)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (count > t.v1) AND (t.v2 > t.v3) AND (count > count(1:Int32)) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, count, count(1:Int32)] }
        └─LogicalAgg { group_key: [t.v1, t.v2, t.v3], aggs: [count, count(1:Int32)] }
          └─LogicalProject { exprs: [t.v1, t.v2, t.v3, 1:Int32] }
            └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.v4, t.ts, t._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: (count > t.v1) AND (count > count(1:Int32)) }
    └─LogicalAgg { group_key: [t.v1, t.v2, t.v3], aggs: [count, count(1:Int32)] }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, 1:Int32] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3], predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (t.v2 > t.v3) }
- name: filter project set transpose
  sql: |
    create table t(v1 int, v2 int, v3 int, arr int[]);
    with cte as (select v1, v2, v3, unnest(arr) as arr_unnested from t) select * from cte where v1=10 AND v2=20 AND v3=30 AND arr_unnested=30;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (Unnest($3) = 30:Int32) }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
        └─LogicalProjectSet { select_list: [$0, $1, $2, Unnest($3)] }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.arr, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.v1, t.v2, t.v3, Unnest($3)] }
    └─LogicalFilter { predicate: (t.v1 = 10:Int32) AND (t.v2 = 20:Int32) AND (t.v3 = 30:Int32) AND (Unnest($3) = 30:Int32) }
      └─LogicalProjectSet { select_list: [$0, $1, $2, Unnest($3)] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t.arr, t._row_id] }
- name: filter inner join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: Inner, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [t2.v3, t2.v4], predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
- name: filter left join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 left join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: LeftOuter, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
    └─LogicalJoin { type: LeftOuter, on: true, output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalScan { table: t2, columns: [t2.v3, t2.v4] }
- name: filter right join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 right join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: RightOuter, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalJoin { type: LeftOuter, on: true, output: [t1.v1, t1.v2, t2.v3, t2.v4] }
      ├─LogicalScan { table: t2, columns: [t2.v3, t2.v4], predicate: IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
- name: filter full outer join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    with cte as (select * from t1 full outer join t2) select * from cte where v1 is null AND v2 is null AND v3 is null AND v4 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
      └─LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4] }
        └─LogicalJoin { type: FullOuter, on: true, output: all }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) AND IsNull(t2.v3) AND IsNull(t2.v4) }
    └─LogicalJoin { type: FullOuter, on: true, output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
      └─LogicalScan { table: t2, columns: [t2.v3, t2.v4] }
- name: filter semi join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    with cte as (select * from t1 where exists (select * from t2)) select * from cte where v1 is null AND v2 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalProject { exprs: [t1.v1, t1.v2] }
        └─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalProject { exprs: [t2.v1, t2.v2] }
            └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [] }
- name: filter anti join transpose
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    with cte as (select * from t1 where not exists (select * from t2)) select * from cte where v1 is null AND v2 is null;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2] }
    └─LogicalFilter { predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
      └─LogicalProject { exprs: [t1.v1, t1.v2] }
        └─LogicalApply { type: LeftAnti, on: true, correlated_id: 1 }
          ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
          └─LogicalProject { exprs: [t2.v1, t2.v2] }
            └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftAnti, on: true, output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNull(t1.v1) AND IsNull(t1.v2) }
    └─LogicalScan { table: t2, columns: [] }
- name: now() pushdown with delta expression
  sql: |
    create table t1(v1 timestamp);
    create table t2(v2 timestamp);
    select * from t1 join t2 where v1 = v2 and v1 > now() + '1 hr';
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
    ├─LogicalFilter { predicate: (t1.v1 > (Now + '1 hr':Varchar::Interval)) }
    | └─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden), t2._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, v1, v2] }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t2.v2, t1._row_id, t2._row_id] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamDynamicFilter { predicate: (t1.v1 > (now + '1 hr':Varchar::Interval)), output: [t1.v1, t1._row_id] }
      |   ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      |   └─StreamProject { exprs: [(now + '1 hr':Varchar::Interval)] }
      |     └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t2.v2) }
        └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: now() in a complex cmp expr does not get pushed down
  sql: |
    create table t1(v1 timestamp);
    create table t2(v2 timestamp, v3 interval);
    select * from t1, t2 where v1 = v2 and v1 > now() + v3;
  optimized_logical_plan: |
    LogicalFilter { predicate: (t1.v1 > (Now + t2.v3)) }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1] }
      └─LogicalScan { table: t2, columns: [t2.v2, t2.v3] }
  stream_error: 'Expr error: Invalid parameter now: expressions containing now must be of the form `col [cmp] now() +- [literal]`'
- name: now() in complex cmp expr pushed onto join ON clause results in dynamic filter
  sql: |
    create table t1(v1 timestamp);
    create table t2(v2 timestamp, v3 interval);
    select * from t1 join t2 where v1 = v2 and v1 > now() + v3;
  optimized_logical_plan: |
    LogicalFilter { predicate: (t1.v1 > (Now + t2.v3)) }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1] }
      └─LogicalScan { table: t2, columns: [t2.v2, t2.v3] }
  stream_error: 'Expr error: Invalid parameter now: expressions containing now must be of the form `col [cmp] now() +- [literal]`'
- name: now() does not get pushed to scan, but others do
  sql: |
    create table t1(v1 timestamp, v2 int);
    select * from t1 where v1 > now() + '30 min' and v2 > 5;
  optimized_logical_plan: |
    LogicalFilter { predicate: (t1.v1 > (Now + '30 min':Varchar::Interval)) }
    └─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: (t1.v2 > 5:Int32) }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamDynamicFilter { predicate: (t1.v1 > (now + '30 min':Varchar::Interval)), output: [t1.v1, t1.v2, t1._row_id] }
      ├─StreamFilter { predicate: (t1.v2 > 5:Int32) }
      | └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamProject { exprs: [(now + '30 min':Varchar::Interval)] }
        └─StreamNow { output: [now] }
- name: eq-predicate derived condition other side pushdown in inner join
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    select * from t1 join t2 where t1.v1 = t2.v1 and t1.v1 > 1000;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v1), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: (t1.v1 > 1000:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2], predicate: (t2.v1 > 1000:Int32) }
- name: eq-predicate derived condition other side pushdown in semi join
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    select * from t1 where exists (select * from t2 where t1.v1 = t2.v1 and t2.v1 < 2000) and t1.v1 > 1000;
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: (t1.v1 = t2.v1), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: (t1.v1 > 1000:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1], predicate: (t2.v1 > 1000:Int32) AND (t2.v1 < 2000:Int32) }
- name: eq-predicate derived condition other side pushdown in outer join
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v2 int);
    select * from t1 left join t2 on t1.v1 = t2.v1 where t2.v1 is not null and t1.v1 + 5 is not null;
  optimized_logical_plan: |
    LogicalFilter { predicate: IsNotNull(t2.v1) }
    └─LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v1), output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2], predicate: IsNotNull((t1.v1 + 5:Int32)) }
      └─LogicalScan { table: t2, columns: [t2.v1, t2.v2], predicate: IsNotNull((t2.v1 + 5:Int32)) }
- name: eq-predicate derived condition is banned for impure function e.g. `now()`
  sql: |
    create table t1(v1 timestamp);
    create table t2(v2 timestamp);
    select * from t1 join t2 where v1 = v2 and v1 > now();
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
    ├─LogicalFilter { predicate: (t1.v1 > Now) }
    | └─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, t1._row_id(hidden), t2._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, v1, v2] }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t2.v2, t1._row_id, t2._row_id] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamDynamicFilter { predicate: (t1.v1 > now), output: [t1.v1, t1._row_id] }
      |   ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      |   └─StreamNow { output: [now] }
      └─StreamExchange { dist: HashShard(t2.v2) }
        └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
